
Linux
-----

I have used Linux (debian, and later ubuntu) since around 1997.
This is where I feel most at home and my muscle memory in vim
is where I no logner remember how I do thing, I just think and
my fingers makes it happen.


Programming
-----------

I learned about electronics, flip-flops, SR latches, RAM, CPU's, ALU's, digital electronics and micro controllers when I was about 15. Did not not have access to a compiler back then so I did not learn to program until a bit later. When I was about 17 I started programing in C and assembler and some C++. Mainly games and low level graphic programming. I learned about linux (debian) and spent endless hours exploring the schools network. Socket programming and TCP/IP. I had the fortune to find like minded friends that chalange me and that I learned from. Friends I stil keep in contact with to this day. They introduced me to cryptography and math.


I earned a masters in electrical enginering at KTH in Stockholm. I studied math, maxwell's equations, radio, fourier transform, signal analysis, microwave engineering, control theory, machine learning, neural nets and other types of artificial intelligence. All while working 50% as a programmer at the IT department of Stockholm university.


Over the years I got to try out a number of different languages and types of programming. From assembler and C to java. From perl to ruby, python, Lua and mathlab (mainly using octave). VHDL, FPGA, CPLD's and even some javascript/typescript. Ever adding tools to my toolbox.


Current
-------

I use python a lot. Most often because it is so easy to be productive in it and the abundance of libraries available. Even if the main product is written in C or some other language, I often use python to write test code, test framewords, proof-of-concepts and prototype with it before rewriting or optimizing things in C. It is my sketchbook. I find joy in network programming and well designed state machines, and in general loves to learn.


I find the designing software for testibility (unit testing) often saves much time in the long run and enforces good design. I try to work in short sprints to give customers a chance to give feedback and ensure that the end result is as expected.

One thing I again and again find myself doing when I meet new customers is to introduce continuous integration (CI/CD) such as jenkine, buildbot or gitlab test-runner to help teams maintain good code quality.


Future
------

I would love to work on some product that uses the Rust programming language. The most promising area would be firmware as it should help catch memory related and perhaps concurrency related bugs much earlier and be of great help when there is no MMU.



Programming languages
---------------------
C
Python
(Rust)


OS
--
Linux
Debian
Ubuntu
CentOS


Virtualization
--------------
Virtualbox
Docker
ESXi


Components
----------
systemd
redis
mariadb
postgresql


Methodologies I adhere to
-------------------------
unit testing
test automation


Project management
------------------
TDD
Scrum


Tools I find highly usefull
---------------------------
git
gitlab
docker
wireshark
systemd
redis
rabbitmq

